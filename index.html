<!DOCTYPE HTML>
<html>
	<head>

		<title>TradingView Advanced Charts demo</title>

		<!-- Fix for iOS Safari zooming bug -->
		<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">

		<script type="text/javascript" src="charting_library/charting_library.standalone.js"></script>
		<script type="text/javascript" src="datafeeds/udf/dist/bundle.js"></script>

		<script type="text/javascript">

			function initOnReady() {
        const configurationData = {
          supported_resolutions: [ '5', '10', '30', '60', '240', 'D']
        };

        const feed = {
          onReady: (callback) => {
            console.log('[onReady]: Method call');
            setTimeout(() => callback(configurationData));
          },
          
          searchSymbols: async (userInput, exchange, symbolType, onResultReadyCallback) => {
            console.log('[searchSymbols]: Method call');
            const url = `https://api.dex.guru/v1/tradingview/search?query=${userInput.toUpperCase()}&limit=30&type=${symbolType}&exchange=${exchange}`
            const response = await fetch(url)
            const symbolItems = await response.json()
            onResultReadyCallback(symbolItems);
          },
          
          resolveSymbol: async (symbolName, onSymbolResolvedCallback, onResolveErrorCallback, extension) => {
            console.log('[resolveSymbol]: Method call', symbolName);
            const url = `https://api.dex.guru/v1/tradingview/search?query=${symbolName}`

            const response = await fetch(url)
            const symbols = await response.json()
            const symbolItem = symbols.find(symbol => symbol.ticker === symbolName);

            if (!symbolItem) {
                onResolveErrorCallback('Cannot resolve symbol');
                return;
            }
            const symbolInfo = {
              ticker: symbolItem.ticker,
              name: symbolItem.symbol,
              description: symbolItem.description,
              type: symbolItem.type,
              session: '24x7',
              timezone: 'Etc/UTC',
              exchange: symbolItem.exchange,
              minmov: 1,
              pricescale: 100,
              has_intraday: true,
              supported_resolutions: configurationData.supported_resolutions,
            };
            onSymbolResolvedCallback(symbolInfo);
          },
          
          getBars: async (symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) => {
            console.log('[getBars]: Method call', symbolInfo);
            const { from, firstDataRequest, countBack } = periodParams;
            try {
                const to = new Date().getTime() < new Date(1000 * periodParams.to) ? Math.floor(new Date().getTime()/ 1000) : periodParams.to
                const url = `https://api.dex.guru/v1/tradingview/history?symbol=${symbolInfo.ticker}&resolution=${resolution}&from=${from}&to=${to}`
                const fetchResponse = await fetch(url)
                const response = await fetchResponse.json()

                let bars = []


                if (!response || response.s !== 'ok') {
                  meta.noData = true
                  meta.nextTime = response?.nextTime
                } else {
                  const ohlPresent = response.o !== undefined
                  const volumePresent = response.v !== undefined

                  for (let i = 0; i < response.t.length; ++i) {
                    const barValue = {
                      time: 1000 * response.t[i],
                      close: parseFloat(response.c[i]),
                      open: parseFloat(response.c[i]),
                      high: parseFloat(response.c[i]),
                      low: parseFloat(response.c[i]),
                      isBarClosed: true,
                      isLastBar: false

                    }

                    if (ohlPresent) {
                      barValue.open = parseFloat(response.o[i])
                      barValue.high = parseFloat(response.h[i])
                      barValue.low = parseFloat(response.l[i])
                    }
                    if (volumePresent) {
                      barValue.volume = parseFloat(response.v[i])
                    }
                      bars = [...bars, barValue]
                  }
                } 
                bars[bars.length - 1].isLastBar = true

                onHistoryCallback(bars, { noData: false });
            } catch (error) {
                onErrorCallback(error);
            }
        },
        subscribeBars: (symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) => {
          console.log('[subscribeBars]: Method call with subscriberUID:', subscriberUID);
          const ws = new WebSocket('wss://ws.dex.guru/v1/ws/channels')
          const [ name ] = symbolInfo.ticker.split('-')

          const interval = parseInt(resolution, 10) * 60

          const [ tokenAddress, apendix ] = symbolInfo.ticker.split('-')
          const [ network ] = apendix.split('_')
          const currency = 'S'
          const id = `RoundedCandle.id-${currency}-${1800}-${1}-all-${tokenAddress}`

          ws.onopen = () => ws.send(JSON.stringify({
            type:"subscribe",
            data:{
              channel_id: id,
              params:{
                subscriber_id: id
              }
            }
          }));

          ws.onmessage = (event) => {
            const updateBars = ( update ) => {
              try {
                const lastBar = {
                  time: update.t_rounded * 1000,
                  high: update.h,
                  low: update.l,
                  open: update.o,
                  close: update.c,
                  volume: update.v,
                }
                return lastBar
              } catch (err) {
                console.error('[tvdf: update] error: ', err)
              }
            }
            const { type, data } = JSON.parse(event.data)
            if(type === 'updated'){
              const bar = updateBars(data.update)
              bar && onRealtimeCallback(bar)
            }
          };

        },
        
        unsubscribeBars: (subscriberUID) => {
          console.log('[unsubscribeBars]: Method call with subscriberUID:', subscriberUID);
        },
        }

				var widget = window.tvWidget = new TradingView.widget({
          symbol: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48-eth_USD',
          interval: '5',                       
          fullscreen: true,                      
          container: 'tv_chart_container',
          datafeed: feed,
          library_path: 'charting_library/'
				});
				window.frames[0].focus();
			};

			window.addEventListener('DOMContentLoaded', initOnReady, false);
		</script>

	</head>

	<body style="margin:0px;">
		<div id="tv_chart_container"></div>
	</body>

</html>
